{"componentChunkName":"component---src-pages-projects-js","path":"/projects/","result":{"data":{"allMdx":{"nodes":[{"frontmatter":{"title":"DejaVid","link":"/dejavid","summary":"We propose a novel framework for Semantic Video Retrieval (SVR), where we aim to find videos within a corpus that are semantically similar to a given query video. Difficulties with this problem include identifying semantically relevant events in a video and matching events in videos despite events spanning different durations. One promising technique is Dynamic Time Warping (DTW), which is temporal deformation-invariant but typically only supports low-dimensional data. In this work, we propose a DTW-augmented neural network architecture that learns the semantic relevance of events and features in a video, enabling general-purpose SVR without hand-coded events or features.","status":"current","image":null}},{"frontmatter":{"title":"BRAD: Simplifying Cloud Data Processing with Learned Automated Data Meshes","link":"/brad","summary":"The last decade of database research has led to the prevalence of specialized systems for different workloads. Consequently, organizations often rely on a combination of specialized systems, organized in a Data Mesh. Data meshes present significant challenges for system administrators, including picking the right system for each workload, moving data between systems, maintaining consistency, and correctly configuring each system. Many non-expert end users (e.g., data analysts or app developers) either cannot solve their business problems, or suffer from sub-optimal performance or cost due to this complexity. We envision BRAD, a cloud system that automatically integrates and manages data and systems into an instance-optimized data mesh, allowing users to efficiently store and query data under a unified data model (i.e., relational tables) without knowledge of underlying system details. With machine learning, BRAD automatically deduces the strengths and weaknesses of each engine through a combination of offline training and online probing. Then, BRAD uses these insights to route queries to the most suitable (combination of) system(s) for efficient execution. Furthermore, BRAD automates configuration tuning, resource scaling, and data migration across component systems, and makes recommendations for more impactful decisions, such as adding or removing systems. As such, BRAD exemplifies a new class of systems that utilize machine learning and the cloud to make complex data processing more accessible to end users, raising numerous new problems in database systems, machine learning, and the cloud.\n","status":"current","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAB7CAAAewgFu0HU+AAABtklEQVR42gGrAVT+AP38/P///u7r69vY2/v5+v///0eElxpqdiduhB1qeg1afC5rj327fne7eIbHiYDHgZHJlMbU0cDRy7zNxwCEpr1CeZ5Oi5JQjolUk5K1ydlPsFolswwTkS1GxSgVhEIyapi05qyp3J6w4KWe1JOs1aPm7OTj7OHj698AdJy3I2OUR5ZqTLRJM6E5psPCS46MJ4NjN4N4O45qEWdvPHGa2+768O318+/07Ojy39ni3Nze5Obr9PP2AKa/z4erxm2vfmPJT0e3P7DLxTpwm1WPsrnKz5uvuwtUhDtzmOHm5uPm5ePk49ff29HW087Pz9ne3+Tk5ADH0diot8Sqwcasw76svrPV2uRVpnokny0yoz8zrDUReVEzaZnZ293X2Nrc3dzY4djV2dTb2tjn6eTi4uEA4ebqscjfvtHmz9rp9c627+zq3OTgxc7EyNHKzdfOz9fRrbzJxOPe8Pf09vLw3+Dgz87O3NnW7ujh8/HuAPPz8+7v8Ovt7e7v7+jo6Onp6vXu4vHn1fHo1+vh0vft2sfR1rbW2dTf4eHj597h4dDU1dXZ3OLj4uzw8zaJKpm3+2ydAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/2773c9c418b3e646b6fa592fe1a1a996/1229e/brad.png","srcSet":"/static/2773c9c418b3e646b6fa592fe1a1a996/3d691/brad.png 125w,\n/static/2773c9c418b3e646b6fa592fe1a1a996/4686c/brad.png 250w,\n/static/2773c9c418b3e646b6fa592fe1a1a996/1229e/brad.png 500w,\n/static/2773c9c418b3e646b6fa592fe1a1a996/53906/brad.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/2773c9c418b3e646b6fa592fe1a1a996/0896c/brad.webp 125w,\n/static/2773c9c418b3e646b6fa592fe1a1a996/9c8fc/brad.webp 250w,\n/static/2773c9c418b3e646b6fa592fe1a1a996/8c4ed/brad.webp 500w,\n/static/2773c9c418b3e646b6fa592fe1a1a996/666d5/brad.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":170}}}}},{"frontmatter":{"title":"ECCS: Exposing Critical Causal Structures","link":"/eccs","summary":"For data systems that support causal queries, high quality causal models are  essential to more reliable query results. The golden standard for establishing  causal models for scientific domain data is carefully designed experiments, often  relying on interventions in a laboratory setting. However, interventional  experiments can often be not plausible while building a causal model for  custom domain data. Therefore, people rely on extracting models from observational  data. Standard statistical causal discovery algorithms often do not scale to  accomodate the number of variables and the volume of data in custom scenarios. Most  causal discovery algorithms also cater to downstream tasks with more indirect  measures of accuracy. In this project, we are interested in developing framework  for interactively refine a causal model for such custom domain data systems. The  framework aims to efficiently use itsinteractivity budget to minimize biases in  given Average Treatment Effect (ATE) queries that the user is interested in.\n","status":"past","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABcRAAAXEQHKJvM/AAAB0UlEQVR42mM4ffr0u1u3bl04derUrA0bNvAyAEFoaCgzkAJhJhBWUVFh1woNZWOor2cKDWVgDoXIYcMsDNHR0TL19fV8QJoPKMCJhLm9orLk/ROKZIFsXlMNU2F5eXkBeX19AWF1dV40tVxQA1UYoBwUEJVZIVg+c5NcaPNGxZIZmyzrd9fLxe/Pkpi7tF5pVXKoyrSMaPXc3Fw+JC1MUFqRQVxcnBvE+v//PyNUkEXLLVlozd7TXpevXpt38fEbmU0HN7mdunhq4pUr9WxbVq+ecPPcuXiQizxyc9nRDFQCEdxINrGA+cbGrDOWrrPcv39/y44dx4QuXLigc3D/wQKQgo2bt+Zs3bHHFcSGOgakhxHZQJDTq4BYECkiGGCKQBGUlpbGCuZDIgummcHe3h5kGJOfn59jf39/ATDyfEDiZkB8FYi9oerYYEEAdCELkAZbsGrVKmZ0MWOgT0C0vr5+Wnx8/GIJCYlMEF8KiPVAPoDazgMNBiaQyzZXrtXZUrNO8/CEw3Jri9eKrSrs5URTxwpzBBCoYY1lZC8DXcNy8MDhecBwnI8UeYxIQYMay9C0IwPF0kg0DEt1dHSE1DXWAdMzgwSaHEwfKK2KArElABqwlMvq2k/pAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/721f6e7c648ccb64d42b7f89dd2f385d/4de80/eccs.png","srcSet":"/static/721f6e7c648ccb64d42b7f89dd2f385d/59d3e/eccs.png 125w,\n/static/721f6e7c648ccb64d42b7f89dd2f385d/6899a/eccs.png 250w,\n/static/721f6e7c648ccb64d42b7f89dd2f385d/4de80/eccs.png 500w,\n/static/721f6e7c648ccb64d42b7f89dd2f385d/17711/eccs.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/721f6e7c648ccb64d42b7f89dd2f385d/9a5de/eccs.webp 125w,\n/static/721f6e7c648ccb64d42b7f89dd2f385d/b150d/eccs.webp 250w,\n/static/721f6e7c648ccb64d42b7f89dd2f385d/9ab67/eccs.webp 500w,\n/static/721f6e7c648ccb64d42b7f89dd2f385d/5862e/eccs.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":249}}}}},{"frontmatter":{"title":"FactorJoin Cardinality Estimation","link":"/factorjoin","summary":"Cardinality estimation is one of the most fundamental and challenging problems in query optimization. Neither classical nor learning-based methods yield satisfactory performance when estimating the cardinality of the join queries. They either rely on simplified assumptions leading to ineffective cardinality estimates or build large models to understand the data distributions, leading to long planning times and a lack of generalizability across queries. We propose a new framework FactorJoin for estimating join queries. FactorJoin combines the idea behind the classical join-histogram method to efficiently handle joins with the learning-based methods to accurately capture attribute correlation. Specifically, FactorJoin scans every table in a DB and builds single-table conditional distributions during an offline preparation phase. When a join query comes, FactorJoin translates it into a factor graph model over the learned distributions to effectively and efficiently estimate its cardinality. Unlike existing learning-based methods, FactorJoin does not need to de-normalize joins upfront or require executed query workloads to train the model. Since it only relies on single-table statistics, FactorJoin has small space overhead and is extremely easy to train and maintain. In our evaluation, FactorJoin can produce more effective estimates than the previous state-of-the-art learning-based methods, with 40x less estimation latency, 100x smaller model size, and 100x faster training speed at comparable or better accuracy. In addition, FactorJoin can estimate 10,000 sub-plan queries within one second to optimize the query plan, which is very close to the traditional cardinality estimators in commercial DBMS.","status":"past","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB0UlEQVR42jWSW2/aQBCF+f+/pE99aCulilJATdpEpMIGEwy+G3uNb8SGJoZgzNcJUUcajXZn9sycM9tzHBfTcghWCtcL0TQN2/HEfcyli65PmZszVBoRKA8vcNA1ncq2KRyHWmJuWUwMg0QpenVdU2w+3HZDHNclSXOJAas4xfMCplI8M2ZkaYY21jBmBkpFhAI4Xy6xBNQ0TSzLphdHkSDHZFmGYUxxpKAoCsYTnThRrNdr4iBAxTH7w/5yruqKt0OD8oSJa5NmG2mgaJqG3vF4ZKz/oX/b52l0z+jqCmM4ZC8NOpk+mkwY30ju9pZNWfJucRSzEp/PzUsDPwxl+hTf9+m17YmsSLH8BXkSkwrlPI5otzXn3Y4nfcb1l+8MrwfCorgArkKRY2GyFKrROscWYKXWQt2h13WdFKYYC40g8nmfuJNHx+5MKznLT3ic2qKVIxIUfOrHREVD+1qxLzPemgMv5Zb69SSSnN4nbLl/fODzt6/8GA7YbCrql5adFCRpycx0Meau3JccT2dG5vMlVzUl9V+RQLQ9izxReSDbXDR8QzcW9H8+cPegkcu2z3xYGClp8pubwa/Ll/pvXXcirxLKbcZZlkHg81zvScqGf4L7SMAd4Wi0AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/57ea1302dc5563686e8a5ed5c9115c36/7179c/factorjoin.png","srcSet":"/static/57ea1302dc5563686e8a5ed5c9115c36/11ed4/factorjoin.png 125w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/12eb6/factorjoin.png 250w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/7179c/factorjoin.png 500w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/240df/factorjoin.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/57ea1302dc5563686e8a5ed5c9115c36/66dfd/factorjoin.webp 125w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/8802f/factorjoin.webp 250w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/4882b/factorjoin.webp 500w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/474be/factorjoin.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":197}}}}},{"frontmatter":{"title":"LucidScript","link":"/lucid-script","summary":"Data preparation has been seen as \"janitor work\" yet essential in data-to-insight pipelines. The increasing liberality of data is followed by an explosion in the diversity of data consumers. However, the required technical and domain expertise prevents many from performing extensive data preparation. Further, many seem to be stuck in a vicious cycle of writing one-off programs to process data. Recently, automating data preparation programs has been shown to improve many aspects of the pipeline, including data quality, research reproducibility, and user productivity. We propose a novel approach to automatically improve data preparation programs.","status":"current","image":null}},{"frontmatter":{"title":"LOGos: From Logs to Causal Diagnosis of Large Systems","link":"/logos","summary":"Causal inference can quantify cause-effect relationships in domains as varied as \n medicine, economics and public policy. Production computer systems exhibit a \n similar level of complexity, together with a recurring time-sensitive need to \n diagnose unwanted phenomena. However, such systems are often only observed \n imperfectly and indirectly, through long, messy, semi-structured logs. In this work, \n we want to accelerate large systems debugging by applying causal inference over logs. \n This will let engineers leverage logs to diagnose problems and assess interventions \n in a principled manner. Our proposed framework achieves this through two \n human-in-the-loop modules: (1) The Candidate Cause Ranker, through which engineers \n can determine the causes of a problem without running a full causal discovery algorithm, \n informing possible interventions; and (2) the Interactive Causal Graph Refiner, which \n helps engineers compute an unbiased estimation of the effect of their discovered causes \n without extensive manual causal graph verification. Both modules are powered by the \n insight that only part of the causal graph of the system is needed to correctly quantify \n an effect of interest. We also provide a data preparation pipeline, the Log Converter, \n which transforms raw, messy, real-world logs into an appropriate tabular input for causal \n inference, using methods drawn from data transformation, cleaning, and extraction.\n","status":"past","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABcRAAAXEQHKJvM/AAAByklEQVR42mOor69ngmB7lpkz01jr60PZ/v//z8jAwMAjoaBqV9i7eG3lpBXHKiatOJ3eMH0iUFyIm5tbDEhLMDBwSWjIyUlKCQur2+jaCDJAASMDdsChY+piMn/fjYdrTz74v/nCy//Ttl7YChTn5JeXF0DTKwTEvGDW+vXrdZctXGi4q7UydWdHbQcI7++qT2hubpbPL6ky6Ft/zLdk4orc3LZZBU0LtqfULtjhCHEdg/K6inXCB7v3V66rXt2/rWnT5CN9B/0ZOrq6npYUFJTdWzn31LMtK/6/2r76/83F07YvWLRo7caNG5eALAUFCZBik1BQkJdR0zZlZ2BQAvLVy4OK7e4tufP+2YYn/z9vf///3oLbcxkKiou94+3tOXb2NGfvmdDSvLe/rXVvb33c7NmzVXom9hj3nZ3q27yxPbd8QWVh8/62xLQZab5Aw6SBmHVV4Sqh7TWbK/d37m3Y3bizY3v5Rn8GPIBVw1HDeMG1RY/WP9j0f9OzLf+nnJm2CyguxsPDIwKkmbDqCg0NZQbRq1atYt5fX88CwkAvsoDEYttihVv2ts+Ye3L+2slHpmyp29FUDhKHpgIw2F+/nwWGV4WuYgYAFvnDO3yZjYUAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/80c7036be8fd78e732c48a622ddf0e18/83cf9/logos.png","srcSet":"/static/80c7036be8fd78e732c48a622ddf0e18/661a8/logos.png 125w,\n/static/80c7036be8fd78e732c48a622ddf0e18/86b57/logos.png 250w,\n/static/80c7036be8fd78e732c48a622ddf0e18/83cf9/logos.png 500w,\n/static/80c7036be8fd78e732c48a622ddf0e18/56838/logos.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/80c7036be8fd78e732c48a622ddf0e18/b4e9e/logos.webp 125w,\n/static/80c7036be8fd78e732c48a622ddf0e18/debdb/logos.webp 250w,\n/static/80c7036be8fd78e732c48a622ddf0e18/6732c/logos.webp 500w,\n/static/80c7036be8fd78e732c48a622ddf0e18/820e1/logos.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":178}}}}},{"frontmatter":{"title":"ML for Systems","link":"/mlforsystems","summary":"Our vision for research on ML for Systems is laid out in SageDB, a new type of data processing system that highly specializes to a particular application through code synthesis and machine learning. This vision is also a focus of MIT DSAIL.\nHere, we provide an overview of data systems components that we are currently working on, with more detailed project descriptions in the links, as well as a list of open-source repositories.\nFor high-level descriptions of our research, you can check out our Learned Systems Blog.","status":"current","image":null}},{"frontmatter":{"title":"Practical DB-OS Co-design with Privileged Kernel Bypass","link":"/privileged-kernel-bypass","summary":"We revisits the longstanding challenge of coordinating database systems with general-purpose OS interfaces, such as POSIX, which often lack tailored support for data-intensive workloads. Existing approaches to this DB-OS co-design struggle with limited design space, security risks, and compatibility issues. To overcome these hurdles, we propose a new co-design approach leveraging virtualization to elevate the privilege level of DB processes. Our method enables database systems to fully exploit hardware capabilities via virtualization, while minimizing the need for extensive modifications to the host OS kernel, thereby maintaining compatibility. We demonstrate the effectiveness of our approach through two novel virtual memory mechanisms tailored for database workloads: (1) an efficient snapshotting mechanism that captures memory snapshots at millisecond intervals for in-memory databases and HTAP workloads, and (2) a virtual-memory-assisted buffer pool design without TLB-shootdown. We introduce libdbos, a lightweight guest kernel implementing these mechanisms. Our evaluations highlight significant improvements in latency and efficiency compared to existing snapshotting and buffer pool designs, underscoring the potential of the approach.","status":"current","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAIAAABPIytRAAAACXBIWXMAABcRAAAXEQHKJvM/AAAEF0lEQVR42j1TaXOiaBD2/3/bqv2+U5PZjHFijATRifHCixsvUAEhHoDcl6BmM+u2ye52PfVWvw1Pv33mjsfjbrczTdOyLM/zzA8B3bbtT8VxnP91+z+J4/hyueRUVX16eqrX6w8PD6VSCUVRDMMajUa1Wq1UKvl8Hk6wEATRbDZrtRqCIHd3dzzPv7+/5+C1NE1d1wXfm80GXEZRHIah7/twGobpeaD6SZKEYeD7AB8iBRZYruRPgYth6IIwW8xFWZZWK0WYTTV1JUlLRZZEUZCWC4AozPZ7E3KJoigHmYAzyPx0PNqOw3CTIcnVmzg3EqaCxE/mJDMeTRYUMx4Q7JDiun1qtzNs2wqC4EqG8IB8zFI3TOf795V3kZ2/V/6FUyMUnyHtCblw1OAiu7/g09z6ZfhH2zKDILySIWGIIY5CywmFVbRcJ4vXeLk+zCQXH4rt/owXzeXmsNBiaZ1MlHBnxY69v5KBuVgsOp3OgCD01SokqYhmQoo+sNy23REq2LxaM/BezLBgjFku6A+ClQpJhxA2kGmafoQulcuaKB4Z+kCTKU2dedZoNfn7AnuXXz/XPu0xSYTd9puhW653zRkShqZDkwzT2Ggb5Fu5V8FLX4v3fxTYF3qGT5aEoDIK12QHWI9r088oauq6pmnXao8+BJo+GvMMwS6YV7YrlL5jU1IWSQ0rNKvFBt2aooV6vYyLrMJyHAwMSZIwETmKoiDh4XAIJ0lQpmZpy/WME3R1v1WM3crcb5yNotN9junz0kxut1u9brfdbkOlc/iH9Pt9PwigX2EUxkmcZikowQdCaEMcJYckO6bmfi+IYgfHJUnKsiyn6zoMvuN5wWIek8OEpVKWyTg249kTz51GHBQvHvSSQS+jhuuftel9IXjVgusURzko2vl0ys7naDo+UcSZY9xuZ1v/qTfqUGTAFqsoKKLWMK1WXdefdxgaLufJ6QQx/bsYh+x4JdPkecQZrYbwWFKq6BJFZuWSjDwq6BP3406uPInIo1wq+hAj/P9JPsPTb2+JLKUUkbJ0xtHg4jRizyP2rzF/ZKhk0E2JAUSeDvsR3oo36yTLrmTYCtuyDd0wAdudDTto2e7eAjim6Zh737Z92/m0uJbtwdWD4gbXVkVhhHc7X799yf/I39zeTMRpnMVXpHF0iII4dAMX4Ee+F3pgSbIkiAPY7Ss5iQ8417zBvjx2ir/f/PbjJV8foxiJdMU2gJR737Gbh/aPW+ymK7x0xRY6QCh1uPcMIOYCPxR24+l+jHQfqyQmWLPOsn5Xv0V65TJeao2eiy+F+0bhFvsTF17a00axWezN8a21Ph3Pube3t7WhrQx5Jk9mykQzV4q+3DqvO2e9cV41QxnP+ak0Hi34hSpu7Nedu1YNOYyCy+XyD1k2Yc4NNecOAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/b3ff4da317671ebee4f4cd0eddaec559/40b9c/privileged-kernel-bypass-1.png","srcSet":"/static/b3ff4da317671ebee4f4cd0eddaec559/4aef1/privileged-kernel-bypass-1.png 104w,\n/static/b3ff4da317671ebee4f4cd0eddaec559/a0f23/privileged-kernel-bypass-1.png 208w,\n/static/b3ff4da317671ebee4f4cd0eddaec559/40b9c/privileged-kernel-bypass-1.png 415w","sizes":"(min-width: 415px) 415px, 100vw"},"sources":[{"srcSet":"/static/b3ff4da317671ebee4f4cd0eddaec559/4eea6/privileged-kernel-bypass-1.webp 104w,\n/static/b3ff4da317671ebee4f4cd0eddaec559/b56cd/privileged-kernel-bypass-1.webp 208w,\n/static/b3ff4da317671ebee4f4cd0eddaec559/f4a6b/privileged-kernel-bypass-1.webp 415w","type":"image/webp","sizes":"(min-width: 415px) 415px, 100vw"}]},"width":500,"height":544.578313253012}}}}},{"frontmatter":{"title":"Self-Organizing Data Containers","link":"/sdc","summary":"We propose a new self-organizing, self-optimizing, meta-data rich storage layer for the cloud, called a self-organizing data container (SDC), that enables order-of-magnitude performance improvements in data-intensive applications through instance-optimization, i.e., the adaptation of data representation to exploit both the distribution of the data and the workload operating on it. Unlike existing cloud storage systems like Delta Lake, Apache Iceberg, and Apache Hudi, SDCs capture both data and metadata, like access histories and distributional statistics, and are designed to be flexible enough to encompass a variety of modern high-performance representations for data analytics, including partitioning, replication, indexing, and materialization.","status":"current","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC5klEQVR42j2SS48bRRSF/RtZ8xNYsEEsI4HYMCDBCgREQmGTKIsQ9hGLvIgcxHgyM7g947HH7ve7qqu6utt2f9zxSJR01NVdfc8995ya+LnGWwcskwZvE3ET5kSqp7E9tem43cb4cYGWfW0H1oWjMgPa7dhEGWs/odQO1e6I9cAkbzp2fccitlLksG3Hu6Xis0cLTp6v+PThOd/8fsUnP1/ydlFLUc+3f6z58umSL554fPV0wYPHVzx84R+bTCphvlvXWcvuMDLsR07DhpO/Ux5dFnw/K3nsVXz+JuZD1hDWjl9mOSfvE344y/lJ8PU04sm8OKqcZEoUtgNebGh0hxLZy7zC7BrUfiBtSkKjyIZBmlk+hCl2UDSHnsIqVCfY97idkn8dk19fBXz03Yzf3kZ8/OM5D57dsK1rtC6YxyWnm5g4SQjyks5qzsIIbUvyquJ8tWWx3hAVNb0QJ03LZJZ3PAt6Xm0Nz33H62RglWaE/pL54ppOiMs0YO4tqPKE8yimVAmqlBG1lsaiUCmczUi0ZVLL3L14OE9b0u7AnaVeGLMfmqO3o9OMnTnuD73lzBfzTS4HI/fr/tm1+T1hZnaU3chfvmWld+LLgcuokJBS4qoUFSWFrtnU4qmonQUJmyJlWxR4aU5WF1SCtE4JJI+Jci25tSyFfVEbUtvyb6lZykiJKYl0znQbMNusuMpTvKphLv7dqpL4LjCVHREpIXai0PYVXSMXNPa5iQRJiOs0SMqmDAiCFefeBRc3C3KjadsKVQSYKqbOA3au5nDoOIwDTVcyaU0GzrCeXzB79waVxTBYxianidZcTl+zuZyx19nRT2zN9mrO9OWfrKRmbBXj0B59tL0WhSZhlNR875Srf4QwuGYvikedosMl71++YHE2ZSdq92LBwSk6U6HLBNdUx/dDf09oupqJkftjJPL/YVJMW2CdjFb55NktZbFBq/D47e6slUSdK2ldITU5Vjju1DVdzX+soMVxHDeCWAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/811731006a6018a4ea5dc049b475c50f/272b5/sdc.png","srcSet":"/static/811731006a6018a4ea5dc049b475c50f/12979/sdc.png 125w,\n/static/811731006a6018a4ea5dc049b475c50f/e65a8/sdc.png 250w,\n/static/811731006a6018a4ea5dc049b475c50f/272b5/sdc.png 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/811731006a6018a4ea5dc049b475c50f/03c37/sdc.webp 125w,\n/static/811731006a6018a4ea5dc049b475c50f/6b6cd/sdc.webp 250w,\n/static/811731006a6018a4ea5dc049b475c50f/2a48b/sdc.webp 500w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":323}}}}},{"frontmatter":{"title":"A Declarative System for Optimizing AI Workloads","link":"/palimpzest","summary":"A long-standing goal of data management systems has been to build systems which can compute quantitative insights over large corpora of unstructured data in a cost-effective manner. Until recently, it was difficult and expensive to extract facts from company documents, data from scientific papers, or metrics from image and video corpora. Today's models can accomplish these tasks with high accuracy. However, a programmer who wants to answer a substantive AI-powered query must orchestrate large numbers of models, prompts, and data operations. For even a single query, the programmer has to make a vast number of decisions such as the choice of model, the right inference method, the most cost-effective inference hardware, the ideal prompt design, and so on. The optimal set of decisions can change as the query changes and as the rapidly-evolving technical landscape shifts. In this paper we present Palimpzest, a system that enables anyone to process AI-powered analytical queries simply by defining them in a declarative language. The system uses its cost optimization framework -- which explores the search space of AI models, prompting techniques, and related foundation model optimizations -- to implement the query plan with the best trade-offs between runtime, financial cost, and output data quality.  We describe the workload of AI-powered analytics tasks, the optimization methods that Palimpzest uses, and the prototype system itself. We evaluate Palimpzest on tasks in Legal Discovery, Real Estate Search, and Medical Schema Matching. We show that even our simple prototype offers a range of appealing plans, including one that is 3.3x faster and 2.9x cheaper than the baseline method, while also offering better data quality. With parallelism enabled, Palimpzest can produce plans with up to a 90.3x speedup at 9.1x lower cost relative to a single-threaded GPT-4 baseline, while obtaining an F1-score within 83.5% of the baseline. These require no additional work by the user.","status":"current","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAPoAAAD6AG1e1JrAAADnUlEQVR42mNg0OjBi/rwyUIpzS4ognEZ1VqkTQokTCoYVduYjTsRUlg0A5F6J4NGp5RSdaWDb4GT0f5Gkd29Is3zgw6vsM9J9eqpsOivs3b2T0GoBxoHYTGqNLrZx6/btMrSIivZQ/vPVN7/i9jPVonssTONigjbOUdtZZZuprZncYZdfpItqmbNrrzyKQ0NnUFB+VNnzo3P8XhbIfRvAu/FGqEP7IGzPMKs2vPvThXfH2O+zcY0p8zdyDEJoZnfsCMruqjZ2C8/v9HOK0ViyQSTRb3rO+LXB6hGcXvZb+4J74kvqna7mSB3Xtm7UMi90M8K5EeoZtUmL9/icneLQ036s5PcbS7MVJ3QrHdyUd7yXh89+9PF8v+ahdxtA1Y5mkYH2OfE2E6udWCQKYcGmIpV+cVC7Q9umjdttLp03ZQOLQjc3ipaXSuU3uHrGrksz7o0yqor03J7sc5cd01jWfNWF0Vw6II1q1pXLPb31uGw3pEoP1fCUsivQC86Oz/NPc7baFunytY2oUlOmmHSZueE3DK43Wo5PFLNNJi0OqDOZlStTk31WtKunxliGR9o1ZypG6WrtS1O+FUZ+9ZwgYlu0rM43XO5XVNZXAVZHWRlHP0rk1Rty2GhLZSwskRsc7Hw3CipRT4KM1zly03VN4aKVBmrR2trykk5iOv6aXmHL0+QnpwgX55iJLdxJotOMyyRCCWsChLXFjOZw+3Vxu6Zze5mzG2rKGKhK2YuKeErUNcZPKXqimTwXhmnpREKs1I0C9ViGVXgmgUTQrU0WZnsmBns2WSDlBvKF8cq7y8Qfz5RsMDDUL2vXdGjoNYksUw/riveKMjFaYVAMIdKI9TZfIq5GgqWEjF5upUlcTcnaU1pmuwhfzhZ7GSk0sQgxcrgAOPpfYLJTVGhNieTpdqzmtb6VmvKlyNSGJdFtX9Lqun2mRITe20kPeNYHa9GSv1PV9rqrbEoW3qFu7F8aKGZX25HUXJuauu9uAZu1SaEZhWJvItp+ixsDhXMLh/4fC5y+j7k8V6nbn64VKwi3KHMxXSbk/F+04w7RR2nY+pD1dKgmQyWSzo55StYRaPrbfUPyDgvZvM8pGZf4qS1pkpFOaqhKC1jkoNDnp+TrFw2g3q7mGEFkmZ4TgaSUoWaGo7+VrreRrrzXTQOqloJ29b4pUxm0Gzj0KgQUapHyfwomRtuilob0AYelQZxlVqoOJoamGZsBQ3WcgMDAQDm8HHtgeTaHgAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/8f1face2aa8a892b9a7a7aee1c208b25/33dd0/palimpzest.webp","srcSet":"/static/8f1face2aa8a892b9a7a7aee1c208b25/2c9be/palimpzest.webp 125w,\n/static/8f1face2aa8a892b9a7a7aee1c208b25/0b151/palimpzest.webp 250w,\n/static/8f1face2aa8a892b9a7a7aee1c208b25/33dd0/palimpzest.webp 500w,\n/static/8f1face2aa8a892b9a7a7aee1c208b25/6429b/palimpzest.webp 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[]},"width":500,"height":500}}}}},{"frontmatter":{"title":"SEED: Domain-Specific Data Curation With Large Language Models","link":"/seed","summary":"We present SEED, an LLM-as-compiler approach that automatically generates domain-specific data curation solutions via Large Language Models (LLMs). Once the user describes a task, input data, and expected output, the SEED compiler produces a hybrid pipeline that combines LLM querying with more cost-effective alternatives, such as vector-based caching, LLM-generated code, and small models trained on LLM-annotated data. SEED features an optimizer that automatically selects from the four LLM-assisted modules and forms a hybrid execution pipeline that best fits the task at hand. In comparison to solutions that use the LLM on every data record, SEED achieves state-of-the-art or comparable few-shot performance, while significantly reducing the number of LLM calls.","status":"current","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAELmAABC5gGC1oevAAABU0lEQVR42i2Q226CQBCGef/XaJPSN7A2NumF2gtt4ikYpYAgC8uyZ1h28dTRdjIXk5n883/5vev1ervdGGPbXViW+HQ6WWsvl8vHaPQ+HLpHHZLk1ferqjqfz43WUfQTx1Hbtt6/mPPP6XR/15ez+Vxr/TYY+P4LDJTRMAyfn58QQuCBKxzHMWzg5BGMGaWUkCw5FAj11vXWaiFKhGhdM0JYzbSUgnPJuTPGdV1xzKE7cK7SVFFOalZTru/V9K4nRTEeT7LjcbNcTr6+ldbGGCFEhVDLuSLEdl3vnOekpAWOD3meoRLXIHbWgngbBJ0xwXo9my+VVFopYC7zvBFCUwq/IBqvBeYSFyWhVc24aI3p+75I02C12gVBGkV5mgG84hw+ZlGkwZky/WDxjJSKcS1Vo/RfO9MJQiDhJI436/VqsdjvdhXGKM8BW7BaCAoZNFL+Ag9UfeXKZIieAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/7be1306421f2091a3ecf6303bd507394/037c8/seed.png","srcSet":"/static/7be1306421f2091a3ecf6303bd507394/a140c/seed.png 125w,\n/static/7be1306421f2091a3ecf6303bd507394/24826/seed.png 250w,\n/static/7be1306421f2091a3ecf6303bd507394/037c8/seed.png 500w,\n/static/7be1306421f2091a3ecf6303bd507394/0e732/seed.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/7be1306421f2091a3ecf6303bd507394/388c3/seed.webp 125w,\n/static/7be1306421f2091a3ecf6303bd507394/d281d/seed.webp 250w,\n/static/7be1306421f2091a3ecf6303bd507394/70ccc/seed.webp 500w,\n/static/7be1306421f2091a3ecf6303bd507394/f798f/seed.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":172}}}}},{"frontmatter":{"title":"Serverless State Management Systems","link":"/ssms","summary":"Modern cloud developers face many distributed systems complexities when building disaggregated applications from cloud building blocks. We propose a new class of cloud services, called Serverless State Management Systems (SSMS), that abstracts away these complexities and transparently manages fault-tolerance, deployment, and scaling of a logical cloud application on physical cloud resources. An SSMS, analogous to a DBMS, provides three important abstractions for disaggregated applications: 1) a logical application model, similar to relational algebra, that describes application semantics but abstracts away the deployment details, 2) strong resilient programming primitives, similar to ACID transactions, that simplifies fault-tolerant programming in the cloud, and 3) smart, cost-based optimization schemes that automates scheduling, placement, and other details, similar to a query optimizer. SSMS is an overarching research direction that encapsulates several projects in cloud, distributed and concurrent systems.\n","status":"current","image":null}},{"frontmatter":{"title":"Stage query execution time prediction","link":"/stage","summary":"Query performance (e.g., execution time) prediction is a critical component of modern DBMSes. As a pioneering cloud data warehouse, Amazon Redshift relies on an accurate execution time prediction for many downstream tasks, ranging from high-level optimizations, such as automatically creating materialized views, to low-level tasks on the critical path of query execution, such as admission, scheduling, and execution resource control. Unfortunately, many existing execution time prediction techniques, including those used in Redshift, suffer from cold start issues, inaccurate estimation, and are not robust against workload/data changes. In this paper, we propose a novel hierarchical execution time predictor: the Stage predictor. The Stage predictor is designed to leverage the unique characteristics and challenges faced by Redshift. The Stage predictor consists of three model states: an execution time cache, a lightweight local model optimized for a specific DB instance with uncertainty measurement, and a complex global model that is transferable across all instances in Redshift. We design a systematic approach to use these models that best leverages optimality (cache), instance-optimization (local model), and transferable knowledge about Redshift (global model). Experimentally, we show that the Stage predictor makes more accurate and robust predictions while maintaining a practical inference latency and memory overhead. Overall, the Stage predictor can improve the average query execution latency by 20% on these instances compared to the prior query performance predictor in Redshift.","status":"current","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAACG0lEQVR42k2SaW8aMRRF+f8/pGqrtkkUtbRE2SghYW0gDMzOLPYsMAMMZICUhFNX/VJL1nuS7aN773PFGdXQOp/IRIc8n9MzBa0nh/bIxY1yyrLEtKdMvYBktiDNCmbZgudyRygibMdF102yfEmUzKlMuifovc9s4nsiGXDz6FKt97hoDhjZEhklOK7HWBsrWMZ8sSCOE8amx9VQ8qMfcN6a0rcSgiCgMs9m+IFDkqYUxZokmeF6Ic40IE5nzPOFgsYEoVQQi7FSs1wVSKXGDmI8kRLEGVGasdttqejdIXbnCXsw4QgU2RJ/OMZ7GmN0H3FV/7J/YVtucR41Ju2eqiPE2GQ1y1hv9wqqwNGcbLmhEmlDOpenWO0WiYzQ+wPGl7c4zRZG/Q7t+ifWRMdTOcpuH7PRxLprItptcuXC8OdcNHSq9zaOyKlo+h017Z2y0iG8byt1I/aB4CAlByHZqN5tPmA99PgdSXVm4f0ymDTVIBRQV5C2tWTgrfHTQmUoQsJkim9Z/PW8VNksbJcyFDwHISvXp1gXrIoVhTslNzSGjSGN6pC5LylfDszWJcv1lvVGZRiHMa1Jixu/Trnacnh9JVaTNQ0LwzDx7YC+HKCtJuTqG6VqaPvtjqO69/b6xv/reDxSEUIgpUDEkqvrOu8/fFT1ltrFJadn53z9VuXLyRnV7zXcqUc6S4mThCiOiaJIvZUI8W8HQcgfSG6Jh+PDexIAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/18f5ae06f823afac3e127f90073ebe3e/1e56f/stage.png","srcSet":"/static/18f5ae06f823afac3e127f90073ebe3e/c58e6/stage.png 125w,\n/static/18f5ae06f823afac3e127f90073ebe3e/74dd0/stage.png 250w,\n/static/18f5ae06f823afac3e127f90073ebe3e/1e56f/stage.png 500w,\n/static/18f5ae06f823afac3e127f90073ebe3e/cef58/stage.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/18f5ae06f823afac3e127f90073ebe3e/37d43/stage.webp 125w,\n/static/18f5ae06f823afac3e127f90073ebe3e/0e6f1/stage.webp 250w,\n/static/18f5ae06f823afac3e127f90073ebe3e/f9920/stage.webp 500w,\n/static/18f5ae06f823afac3e127f90073ebe3e/2a4ad/stage.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":216}}}}},{"frontmatter":{"title":"Treeline: An Update-In-Place Key-Value Store for Modern Storage","link":"/treeline","summary":"Many modern key-value stores, such as RocksDB, rely on log-structured merge trees (LSMs). Originally designed for spinning disks, LSMs optimize for write performance by only making sequential writes. But this optimization comes at the cost of reads: LSMs must rely on expensive compaction jobs and Bloom filters—all to maintain reasonable read performance. For NVMe SSDs, we argue that trading off read performance for write performance is no longer always needed. With enough parallelism, NVMe SSDs have comparable random and sequential access performance. This change makes update-in-place designs, which traditionally provide excellent read performance, a viable alternative to LSMs. In our paper, we close the gap between log-structured and update-in-place designs on modern SSDs with the help of new components that take advantage of data and workload patterns. Specifically, we explore three key ideas: (A) record caching for efficient point operations, (B) page grouping for high-performance range scans, and (C) insert forecasting to reduce the reorganization costs of accommodating new records. We evaluate these ideas by implementing them in a prototype update-in-place key-value store called TreeLine. On YCSB, we find that TreeLine outperforms RocksDB and LeanStore by 2.20× and 2.07× respectively on average across the point workloads, and by up to 10.95× and 7.52× overall.","status":"past","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABcRAAAXEQHKJvM/AAADWklEQVR42mPw69RVT57q9LB4ftjDnNm+H6L6zfMYgMB+vz0LAwIwMagwsDPwMwgCSQUgyc8gz8DBUA8Uh4L//xkYQZhh/v5QiaXHk7u3XqrpXneucMrCY1EuIAX19fVAxSDMAMPMQMwKxIJAzAblMyLJwwEjVBIkyMkpyyCl6MstrhEoIskgw8AJkpO35xeQ9ROW4nZlEOPVZFPltGCQFnHnklTzkRQByrN4eKiw+8fLK4Smq0ozqPtLWVmWK//zbjX/H9hp9w+I/7s0GPzxaTP/P3FZVy7IxsJpqWecm/T++7fb/PVttQTRfzzbTP6bFyseBcm3rvbQW3U26+/kTVH/GeRsRSRNC+SiHSp0oh2L9ROts7RyLHPVk6yy1TNC0/20QBrCGz2crUrUE5yr9aMdy/XiXCsNY2zLtRJM8xXcQfJtC52FFxxITOtcFpDBIGQmxGeapaxtmiWrrREtaSTjwOeu4iFir+Qi7MypwikD0qCfLiRtkC6tb5Arp6URIGapGiOqb5wto2uWoqbIgA40wkSMrCvVfnu3mP/3a7P+591i8T+ww+6vQ4P2f9MsOWeQGusy9UWh/Y5gr/oA5YM67f8E9dj9tylXPwSLwHpgqkibaczKIGfDL2hVqOwI9IqTS7WejXm2soNJqoq9caa0o348vwBIg12+qqZrvZGTe72+g3utrq1btYGVbbmmnXmJoh4iyfwHYxCfA8nBLDExxdzxJaESfn6lvAzcDOJAMW54WoQAZg+VXPZcj23s0OQDApxQeR4Qh7djrZ/3lNW+2uFtpgtTJ3l8Dqh3npMxzetzaJPJjMRic8/UevOI8FwD/7xmh/jG6aVL06d4/M6Z6fPfv1ovt2upn4t/uo5XUY99QHSBcTzY9NUX0q8tO506c/mZlOWrz6ffAAmuvpBxf/np1FmrzqetWXUhc9eik/FT11/OvbziSGHT5ps5/7fczv0/bUd4+ZpLOTcXHk1s23Qzb9+UzdE3wd6cuTtm9ZSt4VXTdkS2zdkXuxokOHd//IYZuyKrZuyK7py5K3LK5G2h5XP2xS2dsDE4Zva+2MtzD8Zd6ljmGw/Uu65nbWDuwkNJM+pm+G6DhQ0sPLiAmA/K54KGDScqW5wbmv1AEcYPxKKgYIOxAdvBIOO26lOHAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/94d927582edb121b9b568797f6d1b3c6/c0db1/architecture.png","srcSet":"/static/94d927582edb121b9b568797f6d1b3c6/8849b/architecture.png 125w,\n/static/94d927582edb121b9b568797f6d1b3c6/35f49/architecture.png 250w,\n/static/94d927582edb121b9b568797f6d1b3c6/c0db1/architecture.png 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/94d927582edb121b9b568797f6d1b3c6/2d7e5/architecture.webp 125w,\n/static/94d927582edb121b9b568797f6d1b3c6/e578d/architecture.webp 250w,\n/static/94d927582edb121b9b568797f6d1b3c6/73619/architecture.webp 500w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":329}}}}},{"frontmatter":{"title":"ML for Systems Papers","link":"/mlforsystems/papers","summary":"If you want to find out more about the exciting work in the area of ML for Systems, we have also compiled a list of ML for Systems Papers. This list is incomplete. If we are missing a paper, please email mlsyspapers@lists.csail.mit.edu and we will include it. If you would like to be informed about new research papers, subscribe here.","status":"current","image":null}}]}},"pageContext":{}},"staticQueryHashes":["3649515864","465186600"],"slicesMap":{}}