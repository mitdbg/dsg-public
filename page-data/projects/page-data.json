{"componentChunkName":"component---src-pages-projects-js","path":"/projects/","result":{"data":{"allMdx":{"nodes":[{"frontmatter":{"title":"FactorJoin Cardinality Estimation","link":"/factorjoin","summary":"Cardinality estimation is one of the most fundamental and challenging problems in query optimization. Neither classical nor learning-based methods yield satisfactory performance when estimating the cardinality of the join queries. They either rely on simplified assumptions leading to ineffective cardinality estimates or build large models to understand the data distributions, leading to long planning times and a lack of generalizability across queries. We propose a new framework FactorJoin for estimating join queries. FactorJoin combines the idea behind the classical join-histogram method to efficiently handle joins with the learning-based methods to accurately capture attribute correlation. Specifically, FactorJoin scans every table in a DB and builds single-table conditional distributions during an offline preparation phase. When a join query comes, FactorJoin translates it into a factor graph model over the learned distributions to effectively and efficiently estimate its cardinality. Unlike existing learning-based methods, FactorJoin does not need to de-normalize joins upfront or require executed query workloads to train the model. Since it only relies on single-table statistics, FactorJoin has small space overhead and is extremely easy to train and maintain. In our evaluation, FactorJoin can produce more effective estimates than the previous state-of-the-art learning-based methods, with 40x less estimation latency, 100x smaller model size, and 100x faster training speed at comparable or better accuracy. In addition, FactorJoin can estimate 10,000 sub-plan queries within one second to optimize the query plan, which is very close to the traditional cardinality estimators in commercial DBMS.","status":"current","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB0UlEQVR42jWSW2/aQBCF+f+/pE99aCulilJATdpEpMIGEwy+G3uNb8SGJoZgzNcJUUcajXZn9sycM9tzHBfTcghWCtcL0TQN2/HEfcyli65PmZszVBoRKA8vcNA1ncq2KRyHWmJuWUwMg0QpenVdU2w+3HZDHNclSXOJAas4xfMCplI8M2ZkaYY21jBmBkpFhAI4Xy6xBNQ0TSzLphdHkSDHZFmGYUxxpKAoCsYTnThRrNdr4iBAxTH7w/5yruqKt0OD8oSJa5NmG2mgaJqG3vF4ZKz/oX/b52l0z+jqCmM4ZC8NOpk+mkwY30ju9pZNWfJucRSzEp/PzUsDPwxl+hTf9+m17YmsSLH8BXkSkwrlPI5otzXn3Y4nfcb1l+8MrwfCorgArkKRY2GyFKrROscWYKXWQt2h13WdFKYYC40g8nmfuJNHx+5MKznLT3ic2qKVIxIUfOrHREVD+1qxLzPemgMv5Zb69SSSnN4nbLl/fODzt6/8GA7YbCrql5adFCRpycx0Meau3JccT2dG5vMlVzUl9V+RQLQ9izxReSDbXDR8QzcW9H8+cPegkcu2z3xYGClp8pubwa/Ll/pvXXcirxLKbcZZlkHg81zvScqGf4L7SMAd4Wi0AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/57ea1302dc5563686e8a5ed5c9115c36/7179c/factorjoin.png","srcSet":"/static/57ea1302dc5563686e8a5ed5c9115c36/11ed4/factorjoin.png 125w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/12eb6/factorjoin.png 250w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/7179c/factorjoin.png 500w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/240df/factorjoin.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/57ea1302dc5563686e8a5ed5c9115c36/66dfd/factorjoin.webp 125w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/8802f/factorjoin.webp 250w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/4882b/factorjoin.webp 500w,\n/static/57ea1302dc5563686e8a5ed5c9115c36/474be/factorjoin.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":197}}}}},{"frontmatter":{"title":"DejaVid","link":"/dejavid","summary":"We propose a novel framework for Semantic Video Retrieval (SVR), where we aim to find videos within a corpus that are semantically similar to a given query video. Difficulties with this problem include identifying semantically relevant events in a video and matching events in videos despite events spanning different durations. One promising technique is Dynamic Time Warping (DTW), which is temporal deformation-invariant but typically only supports low-dimensional data. In this work, we propose a DTW-augmented neural network architecture that learns the semantic relevance of events and features in a video, enabling general-purpose SVR without hand-coded events or features.","status":"current","image":null}},{"frontmatter":{"title":"BRAD: Simplifying Cloud Data Processing with Learned Automated Data Meshes","link":"/brad","summary":"The last decade of database research has led to the prevalence of specialized systems for different workloads. Consequently, organizations often rely on a combination of specialized systems, organized in a Data Mesh. Data meshes present significant challenges for system administrators, including picking the right system for each workload, moving data between systems, maintaining consistency, and correctly configuring each system. Many non-expert end users (e.g., data analysts or app developers) either cannot solve their business problems, or suffer from sub-optimal performance or cost due to this complexity. We envision BRAD, a cloud system that automatically integrates and manages data and systems into an instance-optimized data mesh, allowing users to efficiently store and query data under a unified data model (i.e., relational tables) without knowledge of underlying system details. With machine learning, BRAD automatically deduces the strengths and weaknesses of each engine through a combination of offline training and online probing. Then, BRAD uses these insights to route queries to the most suitable (combination of) system(s) for efficient execution. Furthermore, BRAD automates configuration tuning, resource scaling, and data migration across component systems, and makes recommendations for more impactful decisions, such as adding or removing systems. As such, BRAD exemplifies a new class of systems that utilize machine learning and the cloud to make complex data processing more accessible to end users, raising numerous new problems in database systems, machine learning, and the cloud.\n","status":"current","image":null}},{"frontmatter":{"title":"Serverless State Management Systems","link":"/ssms","summary":"Modern cloud developers face many distributed systems complexities when building disaggregated applications from cloud building blocks. We propose a new class of cloud services, called Serverless State Management Systems (SSMS), that abstracts away these complexities and transparently manages fault-tolerance, deployment, and scaling of a logical cloud application on physical cloud resources. An SSMS, analogous to a DBMS, provides three important abstractions for disaggregated applications: 1) a logical application model, similar to relational algebra, that describes application semantics but abstracts away the deployment details, 2) strong resilient programming primitives, similar to ACID transactions, that simplifies fault-tolerant programming in the cloud, and 3) smart, cost-based optimization schemes that automates scheduling, placement, and other details, similar to a query optimizer. SSMS is an overarching research direction that encapsulates several projects in cloud, distributed and concurrent systems.\n","status":"current","image":null}},{"frontmatter":{"title":"LucidScript","link":"/lucid-script","summary":"Data preparation has been seen as \"janitor work\" yet essential in data-to-insight pipelines. The increasing liberality of data is followed by an explosion in the diversity of data consumers. However, the required technical and domain expertise prevents many from performing extensive data preparation. Further, many seem to be stuck in a vicious cycle of writing one-off programs to process data. Recently, automating data preparation programs has been shown to improve many aspects of the pipeline, including data quality, research reproducibility, and user productivity. We propose a novel approach to automatically improve data preparation programs.","status":"current","image":null}},{"frontmatter":{"title":"Stage query execution time prediction","link":"/stage","summary":"Query performance (e.g., execution time) prediction is a critical component of modern DBMSes. As a pioneering cloud data warehouse, Amazon Redshift relies on an accurate execution time prediction for many downstream tasks, ranging from high-level optimizations, such as automatically creating materialized views, to low-level tasks on the critical path of query execution, such as admission, scheduling, and execution resource control. Unfortunately, many existing execution time prediction techniques, including those used in Redshift, suffer from cold start issues, inaccurate estimation, and are not robust against workload/data changes. In this paper, we propose a novel hierarchical execution time predictor: the Stage predictor. The Stage predictor is designed to leverage the unique characteristics and challenges faced by Redshift. The Stage predictor consists of three model states: an execution time cache, a lightweight local model optimized for a specific DB instance with uncertainty measurement, and a complex global model that is transferable across all instances in Redshift. We design a systematic approach to use these models that best leverages optimality (cache), instance-optimization (local model), and transferable knowledge about Redshift (global model). Experimentally, we show that the Stage predictor makes more accurate and robust predictions while maintaining a practical inference latency and memory overhead. Overall, the Stage predictor can improve the average query execution latency by 20% on these instances compared to the prior query performance predictor in Redshift.","status":"current","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAACG0lEQVR42k2SaW8aMRRF+f8/pGqrtkkUtbRE2SghYW0gDMzOLPYsMAMMZICUhFNX/VJL1nuS7aN773PFGdXQOp/IRIc8n9MzBa0nh/bIxY1yyrLEtKdMvYBktiDNCmbZgudyRygibMdF102yfEmUzKlMuifovc9s4nsiGXDz6FKt97hoDhjZEhklOK7HWBsrWMZ8sSCOE8amx9VQ8qMfcN6a0rcSgiCgMs9m+IFDkqYUxZokmeF6Ic40IE5nzPOFgsYEoVQQi7FSs1wVSKXGDmI8kRLEGVGasdttqejdIXbnCXsw4QgU2RJ/OMZ7GmN0H3FV/7J/YVtucR41Ju2eqiPE2GQ1y1hv9wqqwNGcbLmhEmlDOpenWO0WiYzQ+wPGl7c4zRZG/Q7t+ifWRMdTOcpuH7PRxLprItptcuXC8OdcNHSq9zaOyKlo+h017Z2y0iG8byt1I/aB4CAlByHZqN5tPmA99PgdSXVm4f0ymDTVIBRQV5C2tWTgrfHTQmUoQsJkim9Z/PW8VNksbJcyFDwHISvXp1gXrIoVhTslNzSGjSGN6pC5LylfDszWJcv1lvVGZRiHMa1Jixu/Trnacnh9JVaTNQ0LwzDx7YC+HKCtJuTqG6VqaPvtjqO69/b6xv/reDxSEUIgpUDEkqvrOu8/fFT1ltrFJadn53z9VuXLyRnV7zXcqUc6S4mThCiOiaJIvZUI8W8HQcgfSG6Jh+PDexIAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/18f5ae06f823afac3e127f90073ebe3e/1e56f/stage.png","srcSet":"/static/18f5ae06f823afac3e127f90073ebe3e/c58e6/stage.png 125w,\n/static/18f5ae06f823afac3e127f90073ebe3e/74dd0/stage.png 250w,\n/static/18f5ae06f823afac3e127f90073ebe3e/1e56f/stage.png 500w,\n/static/18f5ae06f823afac3e127f90073ebe3e/cef58/stage.png 1000w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/18f5ae06f823afac3e127f90073ebe3e/37d43/stage.webp 125w,\n/static/18f5ae06f823afac3e127f90073ebe3e/0e6f1/stage.webp 250w,\n/static/18f5ae06f823afac3e127f90073ebe3e/f9920/stage.webp 500w,\n/static/18f5ae06f823afac3e127f90073ebe3e/2a4ad/stage.webp 1000w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":216}}}}},{"frontmatter":{"title":"Treeline: An Update-In-Place Key-Value Store for Modern Storage","link":"/treeline","summary":"Many modern key-value stores, such as RocksDB, rely on log-structured merge trees (LSMs). Originally designed for spinning disks, LSMs optimize for write performance by only making sequential writes. But this optimization comes at the cost of reads: LSMs must rely on expensive compaction jobs and Bloom filters—all to maintain reasonable read performance. For NVMe SSDs, we argue that trading off read performance for write performance is no longer always needed. With enough parallelism, NVMe SSDs have comparable random and sequential access performance. This change makes update-in-place designs, which traditionally provide excellent read performance, a viable alternative to LSMs. In our paper, we close the gap between log-structured and update-in-place designs on modern SSDs with the help of new components that take advantage of data and workload patterns. Specifically, we explore three key ideas: (A) record caching for efficient point operations, (B) page grouping for high-performance range scans, and (C) insert forecasting to reduce the reorganization costs of accommodating new records. We evaluate these ideas by implementing them in a prototype update-in-place key-value store called TreeLine. On YCSB, we find that TreeLine outperforms RocksDB and LeanStore by 2.20× and 2.07× respectively on average across the point workloads, and by up to 10.95× and 7.52× overall.","status":"past","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABcRAAAXEQHKJvM/AAADWklEQVR42mPw69RVT57q9LB4ftjDnNm+H6L6zfMYgMB+vz0LAwIwMagwsDPwMwgCSQUgyc8gz8DBUA8Uh4L//xkYQZhh/v5QiaXHk7u3XqrpXneucMrCY1EuIAX19fVAxSDMAMPMQMwKxIJAzAblMyLJwwEjVBIkyMkpyyCl6MstrhEoIskgw8AJkpO35xeQ9ROW4nZlEOPVZFPltGCQFnHnklTzkRQByrN4eKiw+8fLK4Smq0ozqPtLWVmWK//zbjX/H9hp9w+I/7s0GPzxaTP/P3FZVy7IxsJpqWecm/T++7fb/PVttQTRfzzbTP6bFyseBcm3rvbQW3U26+/kTVH/GeRsRSRNC+SiHSp0oh2L9ROts7RyLHPVk6yy1TNC0/20QBrCGz2crUrUE5yr9aMdy/XiXCsNY2zLtRJM8xXcQfJtC52FFxxITOtcFpDBIGQmxGeapaxtmiWrrREtaSTjwOeu4iFir+Qi7MypwikD0qCfLiRtkC6tb5Arp6URIGapGiOqb5wto2uWoqbIgA40wkSMrCvVfnu3mP/3a7P+591i8T+ww+6vQ4P2f9MsOWeQGusy9UWh/Y5gr/oA5YM67f8E9dj9tylXPwSLwHpgqkibaczKIGfDL2hVqOwI9IqTS7WejXm2soNJqoq9caa0o348vwBIg12+qqZrvZGTe72+g3utrq1btYGVbbmmnXmJoh4iyfwHYxCfA8nBLDExxdzxJaESfn6lvAzcDOJAMW54WoQAZg+VXPZcj23s0OQDApxQeR4Qh7djrZ/3lNW+2uFtpgtTJ3l8Dqh3npMxzetzaJPJjMRic8/UevOI8FwD/7xmh/jG6aVL06d4/M6Z6fPfv1ovt2upn4t/uo5XUY99QHSBcTzY9NUX0q8tO506c/mZlOWrz6ffAAmuvpBxf/np1FmrzqetWXUhc9eik/FT11/OvbziSGHT5ps5/7fczv0/bUd4+ZpLOTcXHk1s23Qzb9+UzdE3wd6cuTtm9ZSt4VXTdkS2zdkXuxokOHd//IYZuyKrZuyK7py5K3LK5G2h5XP2xS2dsDE4Zva+2MtzD8Zd6ljmGw/Uu65nbWDuwkNJM+pm+G6DhQ0sPLiAmA/K54KGDScqW5wbmv1AEcYPxKKgYIOxAdvBIOO26lOHAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/94d927582edb121b9b568797f6d1b3c6/c0db1/architecture.png","srcSet":"/static/94d927582edb121b9b568797f6d1b3c6/8849b/architecture.png 125w,\n/static/94d927582edb121b9b568797f6d1b3c6/35f49/architecture.png 250w,\n/static/94d927582edb121b9b568797f6d1b3c6/c0db1/architecture.png 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/94d927582edb121b9b568797f6d1b3c6/2d7e5/architecture.webp 125w,\n/static/94d927582edb121b9b568797f6d1b3c6/e578d/architecture.webp 250w,\n/static/94d927582edb121b9b568797f6d1b3c6/73619/architecture.webp 500w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":329}}}}},{"frontmatter":{"title":"Self-Organizing Data Containers","link":"/sdc","summary":"We propose a new self-organizing, self-optimizing, meta-data rich storage layer for the cloud, called a self-organizing data container (SDC), that enables order-of-magnitude performance improvements in data-intensive applications through instance-optimization, i.e., the adaptation of data representation to exploit both the distribution of the data and the workload operating on it. Unlike existing cloud storage systems like Delta Lake, Apache Iceberg, and Apache Hudi, SDCs capture both data and metadata, like access histories and distributional statistics, and are designed to be flexible enough to encompass a variety of modern high-performance representations for data analytics, including partitioning, replication, indexing, and materialization.","status":"current","image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC5klEQVR42j2SS48bRRSF/RtZ8xNYsEEsI4HYMCDBCgREQmGTKIsQ9hGLvIgcxHgyM7g947HH7ve7qqu6utt2f9zxSJR01NVdfc8995ya+LnGWwcskwZvE3ET5kSqp7E9tem43cb4cYGWfW0H1oWjMgPa7dhEGWs/odQO1e6I9cAkbzp2fccitlLksG3Hu6Xis0cLTp6v+PThOd/8fsUnP1/ydlFLUc+3f6z58umSL554fPV0wYPHVzx84R+bTCphvlvXWcvuMDLsR07DhpO/Ux5dFnw/K3nsVXz+JuZD1hDWjl9mOSfvE344y/lJ8PU04sm8OKqcZEoUtgNebGh0hxLZy7zC7BrUfiBtSkKjyIZBmlk+hCl2UDSHnsIqVCfY97idkn8dk19fBXz03Yzf3kZ8/OM5D57dsK1rtC6YxyWnm5g4SQjyks5qzsIIbUvyquJ8tWWx3hAVNb0QJ03LZJZ3PAt6Xm0Nz33H62RglWaE/pL54ppOiMs0YO4tqPKE8yimVAmqlBG1lsaiUCmczUi0ZVLL3L14OE9b0u7AnaVeGLMfmqO3o9OMnTnuD73lzBfzTS4HI/fr/tm1+T1hZnaU3chfvmWld+LLgcuokJBS4qoUFSWFrtnU4qmonQUJmyJlWxR4aU5WF1SCtE4JJI+Jci25tSyFfVEbUtvyb6lZykiJKYl0znQbMNusuMpTvKphLv7dqpL4LjCVHREpIXai0PYVXSMXNPa5iQRJiOs0SMqmDAiCFefeBRc3C3KjadsKVQSYKqbOA3au5nDoOIwDTVcyaU0GzrCeXzB79waVxTBYxianidZcTl+zuZyx19nRT2zN9mrO9OWfrKRmbBXj0B59tL0WhSZhlNR875Srf4QwuGYvikedosMl71++YHE2ZSdq92LBwSk6U6HLBNdUx/dDf09oupqJkftjJPL/YVJMW2CdjFb55NktZbFBq/D47e6slUSdK2ldITU5Vjju1DVdzX+soMVxHDeCWAAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/811731006a6018a4ea5dc049b475c50f/272b5/sdc.png","srcSet":"/static/811731006a6018a4ea5dc049b475c50f/12979/sdc.png 125w,\n/static/811731006a6018a4ea5dc049b475c50f/e65a8/sdc.png 250w,\n/static/811731006a6018a4ea5dc049b475c50f/272b5/sdc.png 500w","sizes":"(min-width: 500px) 500px, 100vw"},"sources":[{"srcSet":"/static/811731006a6018a4ea5dc049b475c50f/03c37/sdc.webp 125w,\n/static/811731006a6018a4ea5dc049b475c50f/6b6cd/sdc.webp 250w,\n/static/811731006a6018a4ea5dc049b475c50f/2a48b/sdc.webp 500w","type":"image/webp","sizes":"(min-width: 500px) 500px, 100vw"}]},"width":500,"height":323}}}}}]}},"pageContext":{}},"staticQueryHashes":["3649515864","465186600"],"slicesMap":{}}